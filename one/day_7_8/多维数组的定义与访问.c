#include <stdio.h>

int main(int argc, char const *argv[])
{
	/*
						   元素0              元素1
							|				   |
	int buf[3][4];  // { { [1] [2] [3] [4] },  { [5] [6] [7] [8] },  { [9] [10] [11] [12] } }
													  |
											小数组的第2个元素的地址


	buf[1][1]  ==> buf[1] ==   *(buf+1) 是buf数组的第2个元素的首地址  (*(buf+1))[1] == *( (*(buf+1)) + 1 )

	*/

	int buf[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

	printf("buf[1][1] = %d\n", buf[1][1]);

	printf("buf[1][1] = %d\n", *((*(buf + 1)) + 1));

	// char buf[3][4]; //  buf[3]  char[3][4]  [3]    char[4]       {   { {  {int},{int},{int},{int} },{ {},{},{},{} },{ {},{},{},{} } },{ {},{},{} },{ {},{},{} }    }

	// 思考：语句 int buf[10] = {0}; 可以把数组的每个元素都设置为0，那 int buf[10] = {1}; 是否表示把数组的每个元素都设置为1？
	int buff[10] = {1};
	printf("buff[0] = %d\n", buff[0]); // 只有首个元素设置为1
	printf("buff[1] = %d\n", buff[1]);
	// 思考：用户定义一个数组，但是在定义数组之后并没有进行初始化，而是在定义数组之后想要对数组初始化，请问是否可以，如果可以，怎么做？
	int bufff[10];
	bufff[10] = 1; // 初始化只能在定义数组的同时进行
	// 思考：用户定义了一个字符数组 char buf[5]; 用户想要把一个字符序列abcde这5个字符存储到字符数组中，
	// 提供两种方案： char buf[5] = “abcde”;  char  buf[5] ={‘a’,’b’,’c’,’d’,’e’}; 请问两种方案有什么区别？
	// 回答:第一种方案是可靠的，第二种方案是不可靠的，因为用户可能会出现数组越界的情况
	return 0;
}